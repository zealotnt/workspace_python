#!/usr/bin/python
# -*- coding: utf-8 -*-
# @Author: zealotnt
# @Date:   2017-05-14 23:34:45

# ---- IMPORTS
import re
import time
import serial
import struct
import sys
import git
import os
import inspect
from optparse import OptionParser, OptionGroup
def get_git_root():
	CURRENT_DIR = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe()))) + os.sep
	path = CURRENT_DIR
	git_repo = git.Repo(path, search_parent_directories=True)
	git_root = git_repo.git.rev_parse("--show-toplevel")
	return git_root
sys.path.insert(0, get_git_root() + '/test_bluefinserial/bluefinserial')
from utils import *
from datalink_deliver import *
from scan import scan
from utils import *
from sirius_api_crypto import *


from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from Crypto.PublicKey import RSA

# Constants
VALID_TARGET = ["RF", "APP"]

def Test_AutogenerateData(sirius_crypto, options):
	# KEY_SIZE = [512, 1024, 2048, 3072]
	KEY_SIZE = [512, 1024, 2048]

	for idx, keySize in enumerate(KEY_SIZE):
		# print the head of resulr
		err = False
		print("")
		print_ok(">"*40)
		print_ok("Test RSA with keylength = %d" % keySize)
		#######################################
		# Key generation
		private_key = rsa.generate_private_key(public_exponent=65537, key_size=keySize, backend=default_backend())
		public_key = private_key.public_key()

		#######################################
		# Key download
		rsa_n = packl_ctypes(private_key.private_numbers().public_numbers.n)
		rsa_d = packl_ctypes(private_key.private_numbers().d)
		rsa_p = packl_ctypes(private_key.private_numbers().p)
		rsa_q = packl_ctypes(private_key.private_numbers().q)
		rsa_e = private_key.private_numbers().public_numbers.e
		rsa_n = FixedBytes(keySize/8, rsa_n)
		rsa_d = FixedBytes(keySize/8, rsa_d)
		rsa_p = FixedBytes(keySize/8, rsa_p)
		rsa_q = FixedBytes(keySize/8, rsa_q)

		if options.debug >= 2:
			dump_hex(rsa_n, "rsa_n_%s   : " % (keySize))
			dump_hex(rsa_d, "rsa_d_%s   : " % (keySize))

		sirius_crypto.KeyDownload(target=options.target, RSA_n=rsa_n, RSA_d=rsa_d, RSA_e=rsa_e)

		#######################################
		# Doing with rsa
		# encrypt with sirius
		plain_input = FixedBytes(keySize/8, options.message)
		ciphered = sirius_crypto.Rsa(options.target, "ENC", plain_input)
		ciphered = FixedBytes(keySize/8, ciphered)

		# encrypt with native, the compare it with sirius
		pubkey_tup = (private_key.private_numbers().public_numbers.n, long(private_key.private_numbers().public_numbers.e))
		puc_key_2ndframework = RSA.construct(pubkey_tup)
		cipher_cal = puc_key_2ndframework.encrypt(plain_input, keySize)
		cipher_cal = cipher_cal[0]
		if ciphered != cipher_cal:
			print_err("ciphered != cipher_cal")
			dump_hex(ciphered,   "ciphered  : ")
			dump_hex(cipher_cal, "cipher_cal: ")
			err = True
		else:
			print_ok("cipher_sirius compare with cipher_cal: pass")
			if options.debug >= 2:
				dump_hex(ciphered,   "ciphered  : ")

		# decrypt with sirius
		sirius_crypto.KeyDownload(target=options.target, RSA_n=rsa_n, RSA_d=rsa_d, RSA_e=rsa_e)
		plain_ret = sirius_crypto.Rsa(options.target, "DEC", ciphered)
		plain_ret = FixedBytes(keySize/8, plain_ret)

		# print result
		if plain_ret == plain_input:
			print_ok("Check the plaintext_dec return from board, with our plaintext_input: pass")
		else:
			print_err("Check the plaintext_dec return from board, with our plaintext_input: fail")
			dump_hex(plain_ret,   "plain_ret  : ")
			dump_hex(plain_input, "plain_input: ")
			err = True
		if options.debug >= 1 and err == False:
			dump_hex(ciphered,    "ciphered   : ")
			dump_hex(plain_ret,   "plain_ret  : ")
			dump_hex(plain_input, "plain_input: ")
		print_ok("<"*40)
		print("")

def ParseSection(content, pattern):
	"""
	Parse the content in regex section

	return: an array of the sections cut by the pattern
	"""
	match = [(m.start(0), m.end(0)) for m in re.finditer(pattern, content, re.MULTILINE)]
	resultList = []
	for idx, item in enumerate(match):
		startIdx = item[0]
		if idx < len(match) - 1:
			endIdx = match[idx+1][0]
		else:
			endIdx = len(content) - 1
		allLog = content[startIdx:endIdx]
		resultList.append(allLog)
	return resultList

def ParseTestCase(content):
	"""
	Input: content of a test case

	return: a dict that contains key (n, e, d, c, k, Result)
	n,e,d,c,k: Long type
	Result: True (Pass) / False (Fail)
	"""
	def ParseVar(content, var, varType):
		match = re.findall(r'^' + var + r'\s*=\s*(.+)$', content, re.MULTILINE)
		if len(match) != 1:
			sys.stdout.write("%s invlid format, " % var)
			return None
		if varType == long:
			return long(match[0], 16)
		else:
			if match[0] == "Pass":
				return True
			elif match[0] == "Fail":
				return False
			else:
				return None
	result = {
		"name": "",
		"n": long(0),
		"e": long(0),
		"d": long(0),
		"c": long(0),
		"k": long(0),
		"Result": None,
		"keysize": 0,
	}
	varName = ["n", "e", "d", "c", "k", "Result"]
	varType = [long, long, long, long, long, bool]

	for idx, item in enumerate(varName):
		ret = ParseVar(content, varName[idx], varType[idx])
		if not isinstance(ret, varType[idx]):
			return None
		result[varName[idx]] = ret
	if result["Result"] == False:
		return None
	return result

def Test_RSADP(sirius_crypto, options):
	if options.target != "APP":
		print_err("Only app supprt RSADP test vectors")
		return

	f=open("./test_vectors/RSADPComponent800_56B.txt", 'rU')
	testVectorsContent=f.read()
	f.close()

	# Cut the test vectors into sub test vector, mod 1024 and mod 2048
	retListMod = ParseSection(testVectorsContent, r'\[mod = \d+\]')
	if len(retListMod) != 2:
		print_err("Modulus section len not expected, expect:2/receive:%s" % len(retListMod))
		return

	# Cut the test vectors in to COUNT = \d+ section
	testCaseList = []
	testCaseMod1024 = ParseSection(retListMod[0], r'COUNT = \d')
	testCaseMod2048 = ParseSection(retListMod[1], r'COUNT = \d')

	# Parse the testcase
	for idx, testCase in enumerate(testCaseMod1024):
		ret = ParseTestCase(testCase)
		if ret is None:
			sys.stdout.write("Idx %s of 1024 testcase parse fail\r\n" % idx)
			continue
		ret["keysize"] = 1024
		ret["name"] = "Test_1024_idx_%s" % idx
		testCaseList.append(ret)

	for idx, testCase in enumerate(testCaseMod2048):
		ret = ParseTestCase(testCase)
		if ret is None:
			sys.stdout.write("Idx %s of 2048 testcase parse fail\r\n" % idx)
			continue
		ret["keysize"] = 2048
		ret["name"] = "Test_2048_idx_%s" % idx
		testCaseList.append(ret)

	for testCase in testCaseList:
		# Convert from bignum to string byte array
		rsa_n = packl_ctypes(testCase["n"])
		rsa_d = packl_ctypes(testCase["d"])
		rsa_e = packl_ctypes(testCase["e"])
		rsa_n = FixedBytes(testCase["keysize"]/8, rsa_n)
		rsa_d = FixedBytes(testCase["keysize"]/8, rsa_d)
		rsa_e = FixedBytes(testCase["keysize"]/8, rsa_e)

		KAT_rsa_cipher = packl_ctypes(testCase["c"])
		KAT_rsa_cipher = FixedBytes(testCase["keysize"]/8, KAT_rsa_cipher)
		KAT_rsa_plain = packl_ctypes(testCase["k"])
		KAT_rsa_plain = FixedBytes(testCase["keysize"]/8, KAT_rsa_plain)

		if options.debug >= 2:
			dump_hex(rsa_n,          "RSA_n        : ")
			dump_hex(rsa_d,          "RSA_d        : ")
			dump_hex(rsa_e,          "RSA_n        : ")
			dump_hex(KAT_rsa_cipher, "KAT_rsa_plain: ")
			dump_hex(KAT_rsa_plain,  "KAT_rsa_plain: ")

		sirius_crypto.KeyDownload(target=options.target, RSA_n=rsa_n, RSA_d=rsa_d, RSA_e=rsa_e)
		self_ciphered = sirius_crypto.Rsa(options.target, "ENC", KAT_rsa_plain)

		sirius_crypto.KeyDownload(target=options.target, RSA_n=rsa_n, RSA_d=rsa_d, RSA_e=rsa_e)
		self_plain = sirius_crypto.Rsa(options.target, "DEC", KAT_rsa_cipher)

		if self_plain is None:
			print_err ("Test case %s fail" % testCase["name"])
			continue
		if self_ciphered is None:
			print_err ("Test case %s fail" % testCase["name"])
			continue
		if self_plain != KAT_rsa_plain:
			print_err ("Test case %s fail" % testCase["name"])
			dump_hex(self_plain,     "plain_self  : ")
			dump_hex(KAT_rsa_plain,  "plain_kat   : ")
			continue
		if self_ciphered != KAT_rsa_cipher:
			print_err ("Test case %s fail" % testCase["name"])
			dump_hex(self_ciphered,   "ciphered_self  : ")
			dump_hex(KAT_rsa_cipher,  "ciphered_kat   : ")
			continue
		print_ok ("Test case %s pass" % testCase["name"])

def main():
	parser = OptionParser()
	parser.add_option(  "-s", "--serial",
						dest="serial",
						type="string",
						default=BLUEFINSERIAL_DEFAULT_SERIAL_PORT,
						help="define the serial port to use")
	parser.add_option(  "-b", "--baud",
						dest="baud",
						type="string",
						default=BLUEFINSERIAL_BAUDRATE,
						help="define the serial baudrate to use")
	parser.add_option(  "-t", "--target",
						dest="target",
						default="APP",
						help="Choose type of target to send serial API to, any of: %s" % ', '.join(VALID_TARGET))
	parser.add_option(  "-m", "--message",
						dest="message",
						default=os.urandom(63),
						help="the input message to be hashed")
	parser.add_option(  "-d", "--debug",
						dest="debug",
						default=0,
						action="count",
						help="Make the script more verbose")
	parser.add_option(  "--type",
						dest="testType",
						default="NORM",
						help="The test types for the RSA crypto, support: NORM/RSADP")
	(options, args) = parser.parse_args()

	# Init the com port
	try:
		comm = BluefinserialSend(options.serial, options.baud)
	except Exception, e:
		print e
		parser.print_help()
		sys.exit(-1)
	print_ok("Use " + options.serial + " with baudrate = " + str(options.baud))

	sirius_crypto = SiriusAPICrypto(comm)

	if options.testType == "NORM":
		Test_AutogenerateData(sirius_crypto, options)
	elif options.testType == "RSADP":
		Test_RSADP(sirius_crypto, options)
	else:
		print_err("Invalid test type: %s" % options.testType)

if __name__ == "__main__":
	main()
